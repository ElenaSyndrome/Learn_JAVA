2차원 배열
	배열 안에 배열

2차원 배열 선언
	1. 자료형[ ] [ ] 배열명 = {
			{값1, 값2, ...},
			{값2, 값4, ...},
			{값5, 값6, ...},
			....
			};

	2. 자료형[ ][ ] 배열명 = new int[행수][열수];
	3. 자료형[ ][ ] 배열명 = null;	

	int[ ][ ] arrData = {
		{10,20,30},
		{40,50,60},
		};

	▢	arrData
	
        ▢▢	arrData[0] , arrData[1]

▢▢▢		▢▢▢  arrData[0][0] ~ arrData[0][2] / arrData[1][0]~arrData[1][2]
			10 		~30			40		~60

		정방배열 : 각 행마다 열의 갯수가 모두 같은 배열
		비정방배열 : 행마다 열의 갯수가 다른 배열

2중 for문(nested for문)
	for문 안에 for문이 있는 형태
	바깥쪽에 있는 i for문은 다음 반복으로 넘어가기 위해서
	안쪽에 있는 수행할 문장들을 모두 마쳐야 한다. 
	안에 있는 수행할 문장 중에 j for문이 있으므로, 그 j for문이
	모두 완료되어 i for문 입장에서는 모든 수행할 문장을 	
	마친 것이 된다. 따라서 가장 안쪽에 있는 문장은
	(i for문의 반복횟수)*(j for문의 반복횟수) 만큼 수행된다.

	i	j
	0	0 1 2
	1	0 1 2

메소드 
	이름 뒤의 소괄호( )
	단, 키워드 뒤의 ()는 메소드가 아니다.
	모듈화의 시작	

	1. 반복되는 기능, 코드를 쉽게 관리하기 위해 사용
	2. 소스코드 간결화를 위해 사용
	
	f		(x)		= 	2x+1
	메소드	매개			리턴값
	이름		변수

메소드 구조
	
① 리턴타입 ②메소드명(자료형 ③매개변수, 자료형 매개변수, ...){
		④호출시 실행할 문장;
		⑤return 리턴값;
	}
	
	①  
	② 동사형으로 작성한다. eat("치킨") eat("밥") eat("피자")
	③ 생략이 가능하다.
	④ 생략이 가능하다.
	⑤ 생략이 가능하다.

메소드 선언 순서		
	(두 정수의 덧셈 메소드)
	1. 메소드 명을 생각한다.
		void add(){
		
		}
	2. 매개변수를 생각한다. 
		void add(int num1, int num2){
		
		}
	3. 실행할 문장을 생각한다.
		void add(int num1, int num2){
			int result = num1+num2;
		}
	4. 리턴값을 생각한다.
		void add(int num1, int num2){
			int result = num1+num2;
			return result;
		}
	5. 리턴타입을 수정한다. 
		int add(int num1, int num2){
			int result = num1+num2;
			return result;
		}
메소드의 사용
	메소드는 클래스 내부에 있으므로 그 메소드가 속해있는 클래스 타입으로 
	먼저 변수를 만들어주어야 한다. (객체화를 진행해주어야 한다.)
	
	클래스명 변수명 = new 클래스명();
	
	변수.메소드명(값1,값2,...); //매개변수의 갯수와 타입에 맞게 값을 넘겨줘야 한다. 
	변수.메소드명(); // 매개변수가 없는 것은 그대로 이름으로 사용
	
	메소드 사용 부분은 선언부 마지막에 return값이 있다면 사용한 부분 통째로를 그 
	리턴값으로 보아야 한다. 단, return값이 없다면 값으로 봐서는 안된다.

리턴을 사용해야 할 때 
	메소드 내부에 모든 기능이 구현되지 않을 때 
	사용하는 부분에서 아직 할 작업이 남았을 때 
	메소드 기능의 결과를 사용하는 부분에 알려주어야 할 때

	print(add(10,5));
		println(add(10,5));
		printf("%d", add(10,5));

		int add(int num1, int num2){
			int result = num1+num2;
			return result;
		}

리턴을 사용하지 않아도 될 때
	메소드 내부에서 모든 기능이 구현될 때 
	
	














				